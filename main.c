/*
 * Gismar (31/10/2018)
 * Gismar (11/11/2018)
 * 
 * argc = count parameter's number + 1 (program's name or path is fistr parameter)
 * argv[0] - ./program
 * #define CLI_INPUT "--entrada" argv[1] (if or loop) 
 * argv[2] - file.csv
 * #define CLI_OUTPUT "--saida" empty
 * #define CLI_AVG_ENGAGED "--media-empenhado" argv[3] (if or loop)
 * #define CLI_AVG_SETTLED "--media-liquidado" argv[3] (if or loop)
 * #define CLI_AVG_PAID "--media-valor-pago" argv[3] (if or loop)
 * #define CLI_AVG_OVERALL "--media-geral" argv[3] (if or loop)
 * #define CLI_HELP "--ajuda" argv[1] (if or loop)
 * 
 * 
 * 
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h> /* Enable use of the strdup */
#include <getopt.h>
 
#define BUFFER_SIZE 1024
#define MATRIX_SIZE_C 3
#define CLI_INPUT "--entrada"
#define CLI_OUTPUT "--saida"
#define CLI_AVG_ENGAGED "--media-empenhado"
#define CLI_AVG_SETTLED "--media-liquidado"
#define CLI_AVG_PAID "--media-valor-pago"
#define CLI_AVG_OVERALL "--media-geral"
#define CLI_HELP "--ajuda"


void get_values(char filter[], double l_values[]);
double strtodouble (char *str_result[BUFFER_SIZE], int position);
void print_screen_values(int line, int str_line, int column);
void average_overall(int line, int str_line, int column, char option);

double values[BUFFER_SIZE][MATRIX_SIZE_C];

int main(int argc, char *argv[])
{
    FILE *fp; /* Pointer (File type) */
    char buffer[BUFFER_SIZE]; /* Swap Area to receive String generated by File */
    char *read_data[BUFFER_SIZE]; /* Array that allocates data from the "buffer" */
    int read_size = 0; /* Buffer size read */
    int line = 0; /* line counter */
    int index = 0; /* aux */
    int t_index = 0;
    double l_values[MATRIX_SIZE_C];
    char option = 4;
    char parameter[BUFFER_SIZE];

    /* Variables, if you want to work on reading character, the character of array (optional) */
    char filter[BUFFER_SIZE][BUFFER_SIZE];
    char ch;
    int column = 0;
    int str_size = 0;
    int str_line = 0;
    int str_column = 0;
    int aux_i = 0;

  
    while(argc == 1)
    {
        fprintf(stderr, "\n\tFaca assim: %s --parametro <caminho/arquivo> ou %s %s\n\n", argv[0], argv[0], CLI_HELP);
    	return 1;
    }

/*    
    while((strcmp(argv[1], CLI_HELP) == 0))
    {
        fprintf(stderr, "\n\tMensagem de Ajuda...\n\n");
        return 1;    
    }
*/
    /*
    if ((argc == 0))
    {
    	fprintf(stderr, "\n\tFaca assim: %s --parametro <caminho/arquivo> ou %s %s\n\n", argv[0], argv[0], CLI_HELP);
    	return 1;
    }
    */

    if ((strcmp(argv[1], CLI_HELP) != 0) && (strcmp(argv[1], CLI_INPUT) != 0))
    {
        fprintf(stderr, "\n\tFaca assim: %s --parametro <caminho/arquivo> ou %s %s\n\n", argv[0], argv[0], CLI_HELP);
        return 1;    
    }


    if ((strcmp(argv[1], CLI_HELP) == 0))
    {
        fprintf(stderr, "\n\tMensagem de Ajuda...\n\n");
        return 1;    
    }
 
    if ((strcmp(argv[1], CLI_INPUT) == 0))
    { /* Start*/
        
        /* Condition: if file or path exists, will be open in read-mode "r" */
        if ((fp = fopen(argv[2], "r")) == NULL)
        {
            //perror("\n\t<path/file>");
            printf("\n\t<caminho/arquivo>: Caminho (diretorio) ou Arquivo nao encontrados ou omitidos\n\n");
            return 1;
        }
        
        /* Loop: getting line by line, and inserting into a array and after copied to another array */
        while (fgets(buffer, sizeof(buffer), fp) != NULL)
        {
            read_size = strlen(buffer);
            /* "strdup" from <strings.h> doing copy of pointer to pointer */
            read_data[index] = strdup(buffer);
            index++;
            line++;
        }

        //system("clear");
        /* 2 - Printing content allocated in the Array of Strings (char by char) */
        for(index = 0; index < line; index++)
        {
            str_column = strlen(read_data[index]);   
            if (read_data[index][0] == '1')
            {
                //printf("%d %d ", str_line, str_column);
                for(column = 0; column < str_column; column++)
                {
                    ch = read_data[index][column];
                    filter[t_index][column] = ch;
                    //printf("%c", filter[index][column]);
                }
                str_line++;
                t_index++;
            }
            //if (index == (line -1))
                //printf("\n");
        }
        
        for(t_index = 0; t_index < str_line; t_index++)
        {
            str_column = strlen(filter[t_index]);
            //for(column = 0; column < str_column; column++)
            //{
                //printf("%c", filter[index][column]);
            //}
            get_values(filter[t_index], l_values);
            for (column = 0; column < MATRIX_SIZE_C;column++)
            {
                values[t_index][column]= l_values[column];
            }
            //printf("%d -- %s", t_index, filter[t_index]);        
        }

        print_screen_values(line, str_line, column);
        average_overall(line, str_line, column, option);

        return 1;
        

    } /* End*/
        
        /*
        if ((strcmp(argv[3], CLI_AVG_ENGAGED) != 0) || (strcmp(argv[3], CLI_AVG_SETTLED) != 0) || (strcmp(argv[3], CLI_AVG_PAID) != 0))  
        {
            return 1;    
        }
        */
/*
        if ((strcmp(argv[3], CLI_AVG_ENGAGED) == 0))
        {
            option = '1';
            average_overall(line, str_line, column, option);
            return 1;    
        }

        if ((strcmp(argv[3], CLI_AVG_SETTLED) == 0))
        {
            option = '2';
            average_overall(line, str_line, column, option);
            return 1;    
        }

        if ((strcmp(argv[3], CLI_AVG_PAID) == 0))
        {
            option = '3';
            average_overall(line, str_line, column, option);
            return 1;    
        }

        if ((strcmp(argv[3], CLI_AVG_OVERALL) == 0))
        {
            option = '4';
            average_overall(line, str_line, column, option);
            return 1;    
        }

*/      

    fclose(fp);
    return 0;
}

void get_values(char filter[], double l_values[])
{    
    int count = 0;
    char *space = strtok(filter, " ");
    char *str_result[BUFFER_SIZE];
    //double a_values[3];
    //char option = '\0';
    int aux_count;
    double value_engaged;
    double value_settled;
    double value_paid;

    while (space)
    {
        str_result[count] = space;
        space = strtok (NULL, " ");
        count++;
    }
    
    value_engaged = strtodouble(str_result, count - 3);
    //printf(" %2.2f", value_engaged);    
    value_settled = strtodouble(str_result, count - 2);
    //printf(" %2.2f", value_settled);
    value_paid = strtodouble(str_result, count - 1);
    //printf(" %2.2f", value_paid);
    //printf("\n");

    l_values[0] = value_engaged; 
    l_values[1] = value_settled;
    l_values[2] = value_paid;

}

double strtodouble (char *str_result[BUFFER_SIZE], int position)
{
    char temp[BUFFER_SIZE];
    int i, pos_temp = 0;

    for (i = 0; str_result[i] != '\0'; ++i)
    {
        if (str_result[position][i] == ',')
        { //se é virgula troca por ponto
            temp[pos_temp++] = '.';
        }
        else if (str_result[position][i] != '.')
        { //se não for ponto coloca o caretere
            temp[pos_temp++] = str_result[position][i];
        }
    }
    temp[pos_temp] = '\0'; //terminador no novo

    return atof(temp); //atof agora direto no retorno

}

void print_screen_values(int line, int str_line, int column)
{
    int aux_count = 0;
    system("clear");
    for(line = 0; line < str_line; line++)
    {
        if((aux_count == 0) || (aux_count == 40) || (aux_count == 80) || (aux_count == 120))
            printf("\n\t--> Listagem de Valores - Outubro 2018\n\tIndice\t\tValor Empenhado\t\tValor Liquidado\t\tValor Pago\n\t--------------------------------------------------------------------------\n");

        printf("\t%d", aux_count++);
        for(column = 0; column < MATRIX_SIZE_C; column++)
        {
            printf("\t\tR$ %2.2f ", values[line][column]);
        }
        printf("\n");   
    }

}

void average_overall(int line, int str_line, int column, char option)
{
    double value_engaged = 0;
    double value_settled = 0;
    double value_paid = 0;
    double avg_value_engaged = 0;
    double avg_value_settled = 0;
    double avg_value_paid = 0;



   for(line = 0; line < str_line; line++)
   {
       for(column = 0; column < MATRIX_SIZE_C; column++)
       {
            if (column == 0)
                value_engaged = value_engaged + values[line][column];

            if (column == 1)
                value_settled = value_settled + values[line][column];

            if (column == 2)
                value_paid = value_paid + values[line][column];
       }
   }

   avg_value_engaged = (value_engaged / str_line);
   avg_value_settled = (value_settled / str_line);
   avg_value_paid = (value_paid / str_line);

   
  /* switch (option)
   {
        case '1':
            printf("\n\n\t+\tMedia - Valor Empenhado\t\tR$ %2.2f\n\n", avg_value_engaged);
            break;
        
        case '2':
            printf("\n\n\t+\tMedia - Valor Liquidado\t\tR$ %2.2f\n\n", avg_value_settled);
            break;

        case '3':
            printf("\n\n\t+\tMedia - Valor Pago\t\tR$ %2.2f\n\n", avg_value_paid);
            break;
        
        case '4':
            printf("\n");
            printf("\n\t+\tMedia - Valor Empenhado\t\tR$ %2.2f\n", avg_value_engaged);
            printf("\n\t+\tMedia - Valor Liquidado\t\tR$ %2.2f\n", avg_value_settled);
            printf("\n\t+\tMedia - Valor Pago\t\tR$ %2.2f\n", avg_value_paid);
            printf("\n");
            break;
   
        default:
            printf("\n\n\t+\tErro... \n\n");
            break;
   }
   */
            printf("\n");
            printf("\n\t+\tMedia - Valor Empenhado\t\tR$ %2.2f\n", avg_value_engaged);
            printf("\n\t+\tMedia - Valor Liquidado\t\tR$ %2.2f\n", avg_value_settled);
            printf("\n\t+\tMedia - Valor Pago\t\tR$ %2.2f\n", avg_value_paid);
            printf("\n");

}
